// SPDX-License-Identifier: Apache-2.0

package tee

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

type (
	Enclave interface {
		// Init initializes the enclave, generating a new secp256k1 ECDSA key and
		// storing it as the enclave's signing key.
		//
		// It returns the public key derived Ethereum address and attestation of
		// correct initialization of the enclave with the generated address. The
		// attestation can be used to verify the enclave with the TEE vendor.
		//
		// The Operator must deploy the contract with the Enclave's address after
		// calling Init.
		Init() (common.Address, []byte, error)

		// Run should be called by the operator after they deployed the contract to
		// start the Enclave with the given parameters. The call blocks until the
		// Enclave has shut down. It can be told to gracefully shutdown by calling
		// Shutdown.
		//
		// The Enclave verifies the parameters upon receival of the first block.
		Run(Parameters) error

		// ProcessBlocks should be called by the Operator to cause the enclave to
		// process the given block(s), logging deposits and exits.
		//
		// Note that BalanceProofs requires an additional k blocks to be known to
		// the Enclave before it reveals an epoch's balance proofs to the operator.
		// k is a security parameter to guarantee enough PoW depth.
		ProcessBlocks(...*Block) error

		// ProcessTXs should be called by the Operator whenever they receive new
		// transactions from users. After a transaction epoch has finished and an
		// additional k blocks made known to the Enclave, the epoch's balance proofs
		// can be received by calling BalanceProofs.
		ProcessTXs(...*Transaction) error

		// DepositProofs returns the deposit proofs of all deposits made in an epoch
		// at the end of the deposit phase.
		//
		// Note that all blocks of the epoch's deposit phase (+k) need to be known
		// to the Enclave. This call blocks until all necessary blocks are received
		// and processed.
		//
		// It should be called in a loop by the operator.
		DepositProofs() ([]*DepositProof, error)

		// BalanceProofs returns all balance proofs at the end of each transaction
		// phase.
		//
		// Note that all blocks of the epoch's transaction phase (+k) need to be
		// known to the Enclave. This call blocks until all necessary blocks are
		// received and processed.
		//
		// It should be called in a loop by the operator.
		BalanceProofs() ([]*BalanceProof, error)

		// Shutdown signals the Enclave to gracefully shutdown after the next phase
		// is sealed. It will continue receiving transactions and blocks until the
		// last block of the current phase is received via ProcessBlocks.
		//
		// The functions ProcessBlocks, ProcessTXs, DepositProofs and BalanceProofs
		// will return an ErrEnclaveStopped error after the Enclave shut down.
		// The operator should test for this error in their loops around those
		// functions.
		Shutdown()
	}

	// Epoch is the epoch counter type.
	Epoch = uint64

	// A Block is a go-ethereum block together with its receipts. go-ethereum's
	// types.Block type doesn't store the receipts...
	Block struct {
		types.Block
		Receipts types.Receipts
	}

	// A DepositProof is generated by the Enclave at the end of each deposit phase
	// for each account that made a deposit. The Operator has to forward those to
	// the users or risks facing an on-chain challenge.
	DepositProof struct {
		Balance Balance `json:"balance"`
		Sig     Sig     `json:"sig"`
	}

	// A BalanceProof is generated by the Enclave at the end of each transaction
	// phase for each account in the system. The Operator has to forward those to
	// the users or risks facing an on-chain challenge.
	BalanceProof struct {
		Balance Balance `json:"balance"`
		Sig     Sig     `json:"sig"`
	}

	// A Balance states the balance of the user with address Account in the system
	// at epoch Epoch.
	//
	// Its Solidity struct type is (uint64, address, uint256).
	Balance struct {
		Epoch   Epoch          `json:"epoch"`   // sol: uint64
		Account common.Address `json:"account"` // sol: address
		Value   *Amount        `json:"value"`   // sol: uint256
	}

	// Sig represents an ethereum signature. It is always 65 bytes long.
	Sig []byte
	// Amount is a big.Int wrapper to allow for json en-decoding.
	Amount big.Int
)

func (s Sig) MarshalJSON() ([]byte, error) {
	if len(s) != 65 {
		panic("Invalid signature lenght")
	}
	return json.Marshal("0x" + hex.EncodeToString(s))
}

func (s *Sig) UnmarshalJSON(data []byte) error {
	var aux string
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*s = make([]byte, 65)
	_, err := hex.Decode(*s, []byte(aux)[2:])
	return err
}

func (a Amount) MarshalJSON() ([]byte, error) {
	return json.Marshal(((*big.Int)(&a)).String())
}

func (a *Amount) UnmarshalJSON(data []byte) error {
	var aux string
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	_, ok := (*big.Int)(a).SetString(aux, 10)
	if !ok {
		return fmt.Errorf("Could not parse big.Int")
	}
	return nil
}

func (b *Balance) Clone() Balance {
	return Balance{
		Epoch:   b.Epoch,
		Account: b.Account,
		Value:   (*Amount)(new(big.Int).Set((*big.Int)(b.Value))),
	}
}
